# A0143132X
###### \java\seedu\address\commons\util\StringUtil.java
``` java
    /**
     * Returns true if the {@code sentence} contains the {@code substring}.
     *   Ignores case, but substring match is required.
     *   <br>examples:<pre>
     *       containsSubstringIgnoreCase("ABc def", "abc") == true
     *       containsSubstringIgnoreCase("ABc def", "DEF") == true
     *       containsSubstringIgnoreCase("ABc def", "AB") == true //not a full word match
     *       </pre>
     * @param sentence cannot be null
     * @param substring cannot be null, cannot be empty, must be a single word
     */
    public static boolean containsSubstringIgnoreCase(String sentence, String substring) {
        assert substring != null : "Word parameter cannot be null";
        assert sentence != null : "Sentence parameter cannot be null";

        String preppedWord = substring.trim();
        assert !preppedWord.isEmpty() : "Word parameter cannot be empty";
        assert preppedWord.split("\\s+").length == 1 : "Word parameter should be a single word";

        String preppedSentence = sentence;
        String[] wordsInPreppedSentence = preppedSentence.split("\\s+");

        for (String wordInSentence: wordsInPreppedSentence) {
            if (wordInSentence.toLowerCase().contains(preppedWord.toLowerCase())) return true;
        }
        return false;
    }
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
package seedu.address.logic.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.label.Label;
import seedu.address.model.label.UniqueLabelList;
import seedu.address.model.task.Deadline;
import seedu.address.model.task.Remarks;
import seedu.address.model.task.StartTime;
import seedu.address.model.task.Task;
import seedu.address.model.task.Title;
import seedu.address.model.task.UniqueTaskList;

/**
 * Adds a task to doitdoit!!.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to toDoList!!. "
            + "Parameters: TITLE (from: START TIME) (till:  DEADLINE) (remarks: REMAKRS) (label: LABELS...) "
            + "(c/ COMPLETIONSTATUS)\n"
            + "OR: TITLE (from: START TIME) (due by:  DEADLINE) (remarks: REMAKRS) (label: LABELS...) "
            + "(c/ COMPLETIONSTATUS)\n"
            + "Example: " + COMMAND_WORD
            + " Complete Assignment 1 from now till next friday remark: 20% of final grade label: Assignment c/yes";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in doitdoit!!";

    private final Task toAdd;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String title, String deadline, String remarks, String startTime, String isCompleted,
            Set<String> labels)
                    throws IllegalValueException {
        final Set<Label> labelSet = new HashSet<>();
        for (String labelName : labels) {
            labelSet.add(new Label(labelName));
        }
        this.toAdd = new Task(
                new Title(title),
                deadline == null ? null : new Deadline(deadline),
                        remarks == null ? null : new Remarks(remarks),
                                startTime == null ? null : new StartTime(startTime),
                                        new UniqueLabelList(labelSet),
                                        (isCompleted.trim().equals("yes"))
                );
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

    }

}
```
###### \java\seedu\address\logic\commands\FindCommand.java
``` java
    private final Set<String> keywords;
    private final boolean isLabel;

    public FindCommand(Set<String> keywords, boolean isLabel) {
        this.keywords = keywords;
        this.isLabel = isLabel;
    }

    @Override
    public CommandResult execute() {
        if (isLabel) {
            model.updateFilteredTaskListByLabel(keywords);
            return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        } else {
            model.updateFilteredTaskList(keywords);
            return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        }
    }

}
```
###### \java\seedu\address\model\label\UniqueLabelList.java
``` java
    public String getStringRepresentation() {
        String labelString = "";
        for (Label label : internalList) {
            labelString = labelString + label.labelName + " ";
        }
        labelString.trim();
        return labelString;
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new TitleAndRemarksQualifier(keywords)));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredTaskListByLabel(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new LabelsQualifier(keywords)));
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    private class TitleAndRemarksQualifier implements Qualifier {
        private Set<String> keyWords;

        TitleAndRemarksQualifier(Set<String> keyWords) {
            this.keyWords = keyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.hasRemarks()) {
                return keyWords.stream()
                        .filter(keyword -> StringUtil.containsSubstringIgnoreCase(task.getTitle().fullTitle, keyword))
                        .findAny()
                        .isPresent() ||
                        keyWords.stream()
                        .filter(keyword -> StringUtil.containsSubstringIgnoreCase(task.getRemarks().value, keyword))
                        .findAny()
                        .isPresent();

            }
            return keyWords.stream()
                    .filter(keyword -> StringUtil.containsSubstringIgnoreCase(task.getTitle().fullTitle, keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "title and remarks=" + String.join(", ", keyWords);
        }
    }

    private class LabelsQualifier implements Qualifier {
        private Set<String> keyWords;

        LabelsQualifier(Set<String> keyWords) {
            this.keyWords = keyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (!task.getLabels().isEmpty()) {
                return keyWords.stream()
                        .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getLabels()
                                .getStringRepresentation(), keyword))
                        .findAny()
                        .isPresent();
            }
            return false;
        }

        @Override
        public String toString() {
            return "labels=" + String.join(", ", keyWords);
        }
    }

}
```
###### \java\seedu\address\model\task\ReadOnlyTask.java
``` java
package seedu.address.model.task;

import seedu.address.model.label.UniqueLabelList;

/**
 * A read-only immutable interface for a Task in the Todolist!!.
 * Implementations should guarantee: title is present and not null, field values are validated.
 */
public interface ReadOnlyTask {

    Title getTitle();
    Deadline getDeadline();
    Remarks getRemarks();
    StartTime getStartTime();
    boolean getIsCompleted();

    default boolean hasDeadline() {
        return getDeadline() != null;
    }

    default boolean hasRemarks() {
        return getRemarks() != null;
    }

    default boolean hasStartTime() {
        return getStartTime() != null;
    }

    /**
     * The returned LabelList is a deep copy of the internal LabelList,
     * changes on the returned list will not affect the task's internal labels.
     */
    UniqueLabelList getLabels();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getTitle().equals(this.getTitle()) // state checks here onwards
                && ((!other.hasDeadline() && !this.hasDeadline())
                        || (other.hasDeadline() && this.hasDeadline()
                                && other.getDeadline().equals(this.getDeadline())))
                && ((!other.hasRemarks() && !this.hasRemarks())
                        || (other.hasRemarks() && this.hasRemarks()
                                && other.getRemarks().equals(this.getRemarks())))
                && ((!other.hasStartTime() && !this.hasStartTime())
                        || (other.hasStartTime() && this.hasStartTime()
                                && other.getStartTime().equals(this.getStartTime()))));
    }

    /**
     * Formats the Task as text, showing all task details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getTitle());
        if (hasStartTime()) {
            builder.append(" Start Time: ").append(getStartTime());
        }
        if (hasDeadline()) {
            builder.append(" Deadline: ").append(getDeadline());
        }
        if (hasRemarks()) {
            builder.append(" Remarks: ").append(getRemarks());
        }
        if (getIsCompleted()) {
            builder.append(" Completion: ").append(getIsCompleted());
        }
        if (!getLabels().isEmpty()) {
            builder.append(" Labels: ");
            getLabels().forEach(builder::append);
        }
        return builder.toString();
    }

}
```
###### \java\seedu\address\model\task\Task.java
``` java
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setTitle(replacement.getTitle());
        if (replacement.hasDeadline()) {
            this.setDeadline(replacement.getDeadline());
        }
        if (replacement.hasRemarks()) {
            this.setRemarks(replacement.getRemarks());
        }
        if (replacement.hasStartTime()) {
            this.setStartTime(replacement.getStartTime());
        }
        this.setLabels(replacement.getLabels());
        this.setIsCompleted(replacement.getIsCompleted());
    }
```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java
package seedu.address.storage;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlElement;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.label.Label;
import seedu.address.model.label.UniqueLabelList;
import seedu.address.model.task.Deadline;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.Remarks;
import seedu.address.model.task.StartTime;
import seedu.address.model.task.Task;
import seedu.address.model.task.Title;

/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String title;
    @XmlElement(required = false)
    private String deadline;
    @XmlElement(required = false)
    private String remarks;
    @XmlElement(required = false)
    private String startTime;
    @XmlElement(required = true)
    private boolean isCompleted;

    @XmlElement
    private List<XmlAdaptedLabel> labeled = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        title = source.getTitle().fullTitle;
        if (source.hasDeadline()) {
            deadline = source.getDeadline().value;
        }
        if (source.hasRemarks()) {
            remarks = source.getRemarks().value;
        }
        if (source.hasStartTime()) {
            startTime = source.getStartTime().value;
        }
        isCompleted = source.getIsCompleted();
        labeled = new ArrayList<>();
        for (Label tag : source.getLabels()) {
            labeled.add(new XmlAdaptedLabel(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Label> taskLabels = new ArrayList<>();
        for (XmlAdaptedLabel label : labeled) {
            taskLabels.add(label.toModelType());
        }
        final Title title = new Title(this.title);
        Deadline deadline = null;
        StartTime startTime = null;
        Remarks remarks = null;
        boolean isCompleted = this.isCompleted;
        if (this.deadline != null) {
            deadline = new Deadline(this.deadline);
        }
        if (this.remarks != null) {
            remarks = new Remarks(this.remarks);
        }
        if (this.startTime != null) {
            startTime = new StartTime(this.startTime);
        }
        final UniqueLabelList tags = new UniqueLabelList(taskLabels);
        return new Task(title, deadline, remarks, startTime, tags, isCompleted);
    }
}
```
